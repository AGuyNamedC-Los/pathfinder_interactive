<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <!-- Open Graph -->
        <meta property="og:image" content="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/path.png"/>
        <meta property="og:type" content="website"/>
        <meta property="og:url" content=""/>
        <meta property="og:site_name" content="Pathfinder Interactive"/>
        <meta property="og:title" content="Pathfinder Interactive"/>
        <meta property="og:description" content="An interactive pathfinding website that utilizes path finding algorithms to find the most optimal path between two points"/>

		<title>Interactive Pathfinder</title>
		<link href="pathfinder-interactive.css" type="text/css" rel="stylesheet">
        <link rel="icon" href="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/path.png">
        <!-- Icons made by <a href="https://www.flaticon.com/authors/freepik" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon"> www.flaticon.com</a> -->
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    </head>
    <body>
        <!-- initial POPUP section -->
        <div id="tutorial-pop-up">
            <p>Tutorial</p>
            <div class="slide-progress">    <!-- the little circles at the top of the pop up -->
                <div></div><div></div><div></div><div></div>
            </div>
            <div class="slides">
                <div class="slide tutorial-1">
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-1.gif"/>
                    <p>
                        Pathfinder interactive finds the most optimal path between the starting and goal squares.
                        While also allowing you to move the positions of both the starting and goal squares!<br><br>
                    </p>
                </div>
                <div class="slide tutorial-2" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-2.gif"/>
                    <p>
                        Create walls that make it more difficult for the pathfinding algorithm to find the goal square! Simply 
                        click and drag on blank squares to create black walls. Clicking and dragging on black squares will 
                        create blank squares.
                    </p>
                </div>
                <div class="slide tutorial-3" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-3.gif"/>
                    <p>
                        Note! It is possible to not come to a solution if you create enough walls<br><br><br>
                    </p>
                </div>
                <div class="slide tutorial-4" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-4.gif"/>
                    <p>
                        For now, A* is the only algorithm being used for pathfinding. More soon to come aswell as
                        more features!<br><br><br>
                    </p>
                </div>
            </div>
            <div class="slide-buttons">
                <button onmousedown="tutorialPopUp.changeSlide(-1)">PREV</button>
                <button onmousedown="tutorialPopUp.changeSlide(1)">NEXT</button>
            </div>
        </div>

        <!-- A* Information -->
        <div id="a-star-info">
            <p>A* Star</p>
            <div class="slide-progress">    <!-- the little circles at the top of the pop up -->
                <div></div><div></div><div></div><div></div>
            </div>
            <div class="slides">
                <div class="slide a-star-1">
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-1.gif"/>
                    <p>
                        Pathfinder interactive finds the most optimal path between the starting and goal squares.
                        While also allowing you to move the positions of both the starting and goal squares!<br><br>
                    </p>
                </div>
                <div class="slide a-star-2" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-2.gif"/>
                    <p>
                        Create walls that make it more difficult for the pathfinding algorithm to find the goal square! Simply 
                        click and drag on blank squares to create black walls. Clicking and dragging on black squares will 
                        create blank squares.
                    </p>
                </div>
                <div class="slide a-star-3" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-3.gif"/>
                    <p>
                        Note! It is possible to not come to a solution if you create enough walls<br><br><br>
                    </p>
                </div>
                <div class="slide a-star-4" style=display:none>
                    <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-4.gif"/>
                    <p>
                        For now, A* is the only algorithm being used for pathfinding. More soon to come aswell as
                        more features!<br><br><br>
                    </p>
                </div>
            </div>
            <div class="slide-buttons">
                <button onmousedown="aStarInfo.changeSlide(-1)">PREV</button>
                <button onmousedown="aStarInfo.changeSlide(1)">NEXT</button>
            </div>
        </div>

        <main onmousedown="tutorialPopUp.removePopUp(); aStarInfo.removePopUp()">
            <!-- MENU -->
            <nav>
                <button onclick="aStarAlgo.a_star()">Pathfind!</button>
                <button onclick="aStarAlgo.clearPath()">Clear Path</button>
                <button onclick="aStarAlgo.resetGrid()">Reset</button>
                <button onmousedown="tutorialPopUp.showPopUp()">Tutorial</button>
                <button onmousedown="showCosts()">Show Costs</button>
                <div class="dropdown">
                    <button onmouseover="showDropDown()" onmouseout="dropDownDelay()">Algorithm Info</button>
                    <div onmouseover="showDropDown()" onmouseout="dropDownDelay()" class="algorithms">
                        <div onclick="aStarInfo.showPopUp()">A* Algorithm</div>
                        <div>Dijkstra's Algorithm</div>
                    </div>
                </div>
            </nav>
            <!-- SQUARE LEGEND-->
            <div id="square-legend">
                <div id="start">
                    <div></div>
                    <p>Starting<br>Point</p>
                </div>
                <div id="goal">
                    <div></div>
                    <p>Goal</p>
                </div>
                <div id="wall">
                    <div></div>
                    <p>Wall</p>
                </div>
                <div id="visited">
                    <div></div>
                    <p>Visited</p>
                </div>
                <div id="unvisited">
                    <div></div>
                    <p>Unvisited</p>
                </div>
                <div id="path">
                    <div></div>
                    <p>Optimal<br>Path</p>
                </div>
            </div>
            <!-- MAIN GRID -->
            <div id="grid-container" onmouseup="aStarAlgo.stopPainting()"></div>
        </main>
        <script>
            /* NEW CODE WITH CLASSES */
            var rowSize = 30;
            var columnSize = 15;
            var startSquareIndex;
            var goalSquareIndex;
            const squareSize = "50px";
            const diagonalCost = 14;
            const nonDiagonalCost = 10;
            const start = "start";
            const goal = "goal";
            const wall = "wall";
            const blank = "blank";
            const visited = "visited";
            const unvisited = "unvisited";
            var visible = false;
            var isHovering = false;

            function showDropDown() {
                let temp = document.getElementsByClassName("dropdown")[0].getElementsByClassName("algorithms")[0];
                temp.style.visibility = "visible";
                isHovering = true;
            }

            async function dropDownDelay() {
                let temp = document.getElementsByClassName("dropdown")[0].getElementsByClassName("algorithms")[0];
                temp.style.visibility = "visible";
                console.log("menu still up!");
                isHovering = false;
                setTimeout(function(){
                    let temp = document.getElementsByClassName("dropdown")[0].getElementsByClassName("algorithms")[0];
                    if(!isHovering) { temp.style.visibility = "hidden"; }
                }, 1000);
            }

            class Grid {
                constructor() {
                    this.rowSize = rowSize;
                    this.columnSize = columnSize;
                    this.gridArray = [];
                    this.startSquare;
                    this.goalSquare;

                    // vars to be able to affect the DOM
                    this.gridDOM = document.getElementById("grid-container");
                    this.isMovingStart = false;
                    this.isMovingGoal = false;
                    this.isPainting = false;


                    this.createGrid();      // create the grid
                    // set the start and goal squares
                    this.startSquare = this.gridArray[0];
                    this.startSquare.state = start;
                    this.goalSquare = this.gridArray[this.gridArray.length-1];
                    this.goalSquare.state = goal;
                    startSquareIndex = this.startSquare.index;
                    goalSquareIndex = this.goalSquare.index;

                    console.log(startSquareIndex);
                    console.log(goalSquareIndex);


                    this.createGridHTML();      // create the html for the grid
                    this.colorGrid();   // color the squares accordingly
                }

                // deletes the grid array and then repopulates it with blank squares
                createGrid() {
                    this.gridArray.length = 0;
                    // creating an array of squares
                    for(let i = 0; i < this.columnSize; i++) {
                        for(let j = 0; j < this.rowSize; j++) {
                            this.gridArray.push({"index": (i*this.rowSize)+j,
                                            "position": {"row": j, "col": i},
                                            "directionalCost": "",
                                            "direction": "",
                                            "state": blank, "parent": "",
                                            "startDistance": 0,
                                            "goalDistance": 0,
                                            "total": 0});
                        }
                    }
                }

                // appends squares to the grid div
                createGridHTML() {
                    for(let i = 0; i < this.rowSize * this.columnSize; i++) {
                        if (this.gridArray[i].state != start && this.gridArray[i].state != goal) {
                            $("#grid-container").append(`<div class=square onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">
                                                        <p class="start" onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">${this.gridArray[i]['startDistance']}</p>
                                                        <p class="goal" onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">${this.gridArray[i]['goalDistance']}</p>
                                                        <p class="total" onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">${this.gridArray[i]['total']}</p>
                                                    </div>`);
                        } else if (this.gridArray[i].state == start) {
                            this.startSquare = this.gridArray[i];
                            $("#grid-container").append(`<div class=square onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">
                                                        <p class="start">${this.gridArray[i]['startDistance']}</p>
                                                        <p class="goal">${this.gridArray[i]['goalDistance']}</p>
                                                        <p class="total">${this.gridArray[i]['total']}</p>
                                                    </div>`);
                        } else {
                            this.goalSquare = this.gridArray[i];
                            $("#grid-container").append(`<div class=square onmousedown="aStarAlgo.changeSquare('${this.gridArray[i].index}')" onmouseover="aStarAlgo.painting('${this.gridArray[i].index}')" onmouseup="aStarAlgo.stopPainting()">
                                                        <p class="start">${this.gridArray[i]['startDistance']}</p>
                                                        <p class="goal">${this.gridArray[i]['goalDistance']}</p>
                                                        <p class="total">${this.gridArray[i]['total']}</p>
                                                    </div>`);
                        }

                        // css to create the grid dimensions
                        this.gridDOM.style.gridTemplateColumns = `repeat(${this.rowSize}, ${squareSize})`;
                        this.gridDOM.style.gridTemplateRows = `repeat(${this.columnSize}, ${squareSize})`;
                    }
                }

                // takes input from the grid array to color the grid's HTML
                colorGrid() {
                    for(let i = 0; i < this.columnSize * this.rowSize; i++) {
                        if(this.gridArray[i].state == blank) {
                            this.gridDOM.children[i].style.backgroundColor = "#f2f2f2";
                            this.gridDOM.children[i].style.borderColor = "#959595";
                        } else if(this.gridArray[i].state == unvisited) {
                            this.gridDOM.children[i].style.backgroundColor = "#88FFD1";
                            this.gridDOM.children[i].style.borderColor = "#3FE1B0";
                        } else if(this.gridArray[i].state == visited) { 
                            this.gridDOM.children[i].style.backgroundColor = "#FF848C";
                            this.gridDOM.children[i].style.borderColor = "#FF505F";
                        } else if(this.gridArray[i].state == start) {
                            this.gridDOM.children[i].style.backgroundColor = "#00DDFF";
                            this.gridDOM.children[i].style.borderColor = "#0290EE";
                        } else if(this.gridArray[i].state == goal) {
                            this.gridDOM.children[i].style.backgroundColor = "#C588FF";
                            this.gridDOM.children[i].style.borderColor = "#9059FF";
                        } else if (this.gridArray[i].state == wall) {
                            this.gridDOM.children[i].style.backgroundColor = "black";
                        } else;
                    }
                }

                setUpGrid() {
                    this.deleteGrid();
                    this.createGrid();
                    this.startSquare = this.getSquareByIndex(startSquareIndex);
                    this.startSquare.state = start;
                    this.goalSquare = this.getSquareByIndex(goalSquareIndex);
                    this.goalSquare.state = goal;
                    this.createGridHTML();
                    
                    // dont show values when setting up the grid
                    visible = false;
                    showCosts();
                    this.colorGrid();
                }

                // resets the entire grid except the placement of the walls, start, and goal squares
                clearPath() {
                    for(let i = 0; i < this.gridArray.length; i++) {
                        if(this.gridArray[i].state == unvisited || this.gridArray[i].state == visited) {
                            // reset the square's values except values relted to position
                            this.gridArray[i].directionalCost = 0;
                            this.gridArray[i].state = blank;
                            this.gridArray[i].parent = "";
                            this.gridArray[i].startDistance = 0;
                            this.gridArray[i].goalDistance = 0;
                            this.gridArray[i].total = 0;

                            // css to recolor the square to a blank square
                            this.gridDOM.children[i].style.backgroundColor = "#f2f2f2";
                            this.gridDOM.children[i].style.borderColor = "#959595";

                            // reset the square's HTML values
                            this.gridDOM.children[i].getElementsByTagName("p")[0].innerHTML = this.gridArray[i].startDistance;
                            this.gridDOM.children[i].getElementsByTagName("p")[1].innerHTML = this.gridArray[i].goalDistance;
                            this.gridDOM.children[i].getElementsByTagName("p")[2].innerHTML = this.gridArray[i].total;
                        }
                    }

                    this.colorGrid();   // recolor the grid
                    visible = false;
                    showCosts();
                }

                // completely resets the grid and repositions that start and goal squares to their initial positions
                resetGrid() {
                    this.createGrid();

                    // reinitializing the saved start and goal squares
                    startSquareIndex = 0;
                    goalSquareIndex = this.gridArray.length - 1;
                    this.startSquare = this.getSquareByIndex(startSquareIndex);
                    this.startSquare.state = start;
                    this.goalSquare = this.getSquareByIndex(goalSquareIndex);
                    this.goalSquare.state = goal;

                    

                    this.colorGrid();   // recolor the grid
                    this.updateSquareCosts();   // update the costs for HTML
                    visible = false;
                    showCosts();
                }

                // delete the gridArray as well as the HTML for it
                deleteGrid() {
                    this.gridArray.length = 0;  // deleting the grid array
                    let child = this.gridDOM.lastElementChild;

                    // deleting all the squares from the grid
                    while(child) {
                        this.gridDOM.removeChild(child);
                        child = this.gridDOM.lastElementChild;
                    }
                }

                // applies a new state and resets the squares values except its positons
                resetSquare(square, newState) {
                    square.directionalCost = "";
                    square.direction = "";
                    square.state = newState;
                    square.parent = "";
                    square.startDistance = 0;
                    square.goalDistance = 0;
                    square.total = 0;
                }

                // changes the color of a specific square
                changeSquareColor(square, newState) {
                    if(newState == blank) {
                            this.gridDOM.children[square.index].style.backgroundColor = "#f2f2f2";
                            this.gridDOM.children[square.index].style.borderColor = "#959595";
                        } else if(newState == unvisited) {
                            this.gridDOM.children[square.index].style.backgroundColor = "#88FFD1";
                            this.gridDOM.children[square.index].style.borderColor = "#3FE1B0";
                        } else if(newState == visited) { 
                            this.gridDOM.children[square.index].style.backgroundColor = "#FF848C";
                            this.gridDOM.children[square.index].style.borderColor = "#FF505F";
                        } else if(newState == start) {
                            this.gridDOM.children[square.index].style.backgroundColor = "#00DDFF";
                            this.gridDOM.children[square.index].style.borderColor = "#0290EE";
                        } else if(newState == goal) {
                            this.gridDOM.children[square.index].style.backgroundColor = "#C588FF";
                            this.gridDOM.children[square.index].style.borderColor = "#9059FF";
                        } else if (newState == wall) {
                            this.gridDOM.children[square.index].style.backgroundColor = "black";
                        } else;
                }

                // returns a square from the grid from a given set of coordinates
                getSquareByCoord(row, col) {
                    for (let i = 0; i < this.rowSize * this.columnSize; i++)
                        if(this.gridArray[i].position.row == row && this.gridArray[i].position.col == col)
                            return this.gridArray[i];
                }

                getSquareByIndex(index) {
                    return this.gridArray[index];
                }

                // updates a specific square's HTML values
                updateSquareCost(square) {
                    this.gridDOM.children[square.index].getElementsByTagName("p")[0].innerHTML = square.startDistance;
                    this.gridDOM.children[square.index].getElementsByTagName("p")[1].innerHTML = square.goalDistance;
                    this.gridDOM.children[square.index].getElementsByTagName("p")[2].innerHTML = square.total;
                }

                // displays the costs for distance from the start and goal for each square, as well as the total cost
                updateSquareCosts() {
                    for(let i = 0; i < this.columnSize * this.rowSize; i++) {
                        if(this.gridArray[i].state != wall || this.gridArray[i].state != blank) {
                            this.gridDOM.children[i].getElementsByTagName("p")[0].innerHTML = this.gridArray[i].startDistance;
                            this.gridDOM.children[i].getElementsByTagName("p")[1].innerHTML = this.gridArray[i].goalDistance;
                            this.gridDOM.children[i].getElementsByTagName("p")[2].innerHTML = this.gridArray[i].total;
                        }
                    }
                }

                // color will change on click for a square
                changeSquare(i) {
                    if(!visible) { showCosts(); }

                    if(this.gridArray[i].state == start) {       // ensure only the start square can be moved
                        this.isMovingStart = true;
                        return;
                    } else if(this.gridArray[i].state == goal) {     // ensure only the goal square can be moved
                        this.isMovingGoal = true;
                        return;
                    }

                    this.isPainting = true;
                    if(this.gridArray[i].state == blank) {
                        this.changeSquareColor(this.getSquareByIndex(i), wall);
                        this.resetSquare(this.getSquareByIndex(i), wall);
                    } else if(this.gridArray[i].state == wall) {
                        this.changeSquareColor(this.getSquareByIndex(i), blank);
                        this.resetSquare(this.getSquareByIndex(i), blank);
                    }
                }

                // allows the ability to click and drag squares causing the "paint" effect
                painting(i) {
                    if(this.isMovingStart) {     // allows the ability to click and drag the start square
                        startSquareIndex = i;       // update the global start square's index
                        if(startSquareIndex == goalSquareIndex) { return; } // so we dont overwrite the goalSquare's position

                        // logic to properly change the color of the dragged startSquare over blank squares
                        let temp = JSON.parse(JSON.stringify(this.startSquare));
                        this.startSquare = this.gridArray[i];
                        this.startSquare.state = start;
                        this.startSquare.parent = ""

                        // change the current positon to the start square's color
                        this.changeSquareColor(this.getSquareByIndex(this.startSquare.index), start);

                        // change the previous position to a blank square
                        this.changeSquareColor(this.getSquareByIndex(temp.index), blank);
                        this.resetSquare(this.getSquareByIndex(temp.index), blank);
                        return;
                    } else if (this.isMovingGoal) {      // allows the ability to click and drag the goal square
                        goalSquareIndex = i;    // update the global goal square's index
                        if(goalSquareIndex == startSquareIndex) { return; }     // so we dont overwrite the startSquare's position
                        
                        // logic to properly change the color of the dragged goalSquare over blank squares
                        let temp = JSON.parse(JSON.stringify(this.goalSquare));
                        this.goalSquare = this.gridArray[i];
                        this.goalSquare.state = goal;
                        this.goalSquare.parent = "";

                        // change the current position to the goal square's color
                        this.changeSquareColor(this.getSquareByIndex(this.goalSquare.index), goal);

                        // change the previous position to a blank square
                        this.changeSquareColor(this.getSquareByIndex(temp.index), blank);
                        this.resetSquare(this.getSquareByIndex(temp.index), blank);
                        return;
                    }

                    if(this.isPainting) {        // allows the ability to click and drag to create walls or delete walls
                        if(this.gridArray[i].state == blank) {
                            this.changeSquareColor(this.getSquareByIndex(i), wall);
                            this.resetSquare(this.getSquareByIndex(i), wall);
                        } else if(this.gridArray[i].state == wall) {
                            this.changeSquareColor(this.getSquareByIndex(i), blank);
                            this.resetSquare(this.getSquareByIndex(i), blank);
                        }
                    }
                }

                // stops the ability to click and drag a square after a onmouseup event
                stopPainting() {
                    if(this.isMovingStart) { this.isMovingStart = false; } 
                    else if (this.isMovingGoal) { this.isMovingGoal = false; } 
                    else if(this.isPainting) { this.isPainting = false; }
                }
            }

            class A_Star extends Grid{
                constructor() {
                    super();
                    this.unexploredSquares = [];
                    this.visitedSquares = [];
                }

                // calculates distance of the start and goal from a given square
                setSquareDistance(square) {
                    let currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                    currSquare.startDistance = 0;       // resetting the value so the main copy doesn't have its value added to it
                    let startSquare = this.startSquare;
                    let goalSquare = this.goalSquare;

                    // find the start distance of the current square
                    while (currSquare.position.col != this.startSquare.position.col || currSquare.position.row != this.startSquare.position.row) {
                        if(currSquare.position.col == this.startSquare.position.col) {      // check if square is in the same COLUMN of starting square
                            if (currSquare.position.row < this.startSquare.position.row) {
                                currSquare.position.row += 1;
                                currSquare.startDistance += nonDiagonalCost;
                            } else if (currSquare.position.row > this.startSquare.position.row) { 
                                currSquare.position.row -= 1;
                                currSquare.startDistance += nonDiagonalCost;
                            } else;
                        } else if (currSquare.position.row == this.startSquare.position.row) {      // check if square is in the same ROW of starting square
                            if (currSquare.position.col < this.startSquare.position.col) {
                                currSquare.position.col += 1;
                                currSquare.startDistance += nonDiagonalCost;
                            } else if (currSquare.position.col > this.startSquare.position.col) {
                                currSquare.position.col -= 1;
                                currSquare.startDistance += nonDiagonalCost;
                            } else;
                        } else {        // square is diagonally away from the start square
                            if (currSquare.position.col < this.startSquare.position.col) { currSquare.position.col += 1; }
                            else if (currSquare.position.col > this.startSquare.position.col) {currSquare.position.col -= 1;}
                            else;

                            if(currSquare.position.row < this.startSquare.position.row) { currSquare.position.row += 1; }
                            else if (currSquare.position.row > this.startSquare.position.row) { currSquare.position.row -= 1; }
                            else;

                            currSquare.startDistance += diagonalCost;
                        }
                    }

                    square.startDistance = currSquare.startDistance;        // new startDistance

                    currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                    currSquare.goalDistance = 0;        // resetting the value so the main copy doesn't have its value added to
                    
                    // find the goal distance of a square
                    while (currSquare.position.col != this.goalSquare.position.col || currSquare.position.row != this.goalSquare.position.row) {
                        if(currSquare.position.col == this.goalSquare.position.col) {      // check if node is in the same COLUMN of start square
                            if (currSquare.position.row < this.goalSquare.position.row) {
                                currSquare.position.row += 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else if (currSquare.position.row > this.goalSquare.position.row) { 
                                currSquare.position.row -= 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else;
                        } else if (currSquare.position.row == this.goalSquare.position.row) {      // check if node is in the same ROW of start square
                            if (currSquare.position.col < this.goalSquare.position.col) {
                                currSquare.position.col += 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else if (currSquare.position.col > this.goalSquare.position.col) {
                                currSquare.position.col -= 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else;
                        } else {        // check if the square is in the same DIAGONAL of start square
                            if (currSquare.position.col < this.goalSquare.position.col) { currSquare.position.col += 1; } 
                            else if (currSquare.position.col > this.goalSquare.position.col) { currSquare.position.col -= 1; }
                            else;

                            if(currSquare.position.row < this.goalSquare.position.row) { currSquare.position.row += 1; } 
                            else if (currSquare.position.row > this.goalSquare.position.row) { currSquare.position.row -= 1; } 
                            else;

                            currSquare.goalDistance += diagonalCost;
                        }
                    }

                    square.goalDistance = currSquare.goalDistance;      // new goalDistance
                    if(square.state != this.startSquare.state && square.state != this.goalSquare.state) 
                        square.total = square.startDistance + square.goalDistancel;       // new total distance
                    else 
                        square.total = 0;      
                }

                setSquareDistance(square) {
                    let currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                    currSquare.startDistance = 0;       // resetting the value so the main copy doesn't have its value added to it
                    let startSquare = this.startSquare;
                    let goalSquare = this.goalSquare;

                    // // find the start distance of the current square
                    // while (currSquare.position.col != this.startSquare.position.col || currSquare.position.row != this.startSquare.position.row) {
                    //     if(currSquare.position.col == this.startSquare.position.col) {      // check if square is in the same COLUMN of starting square
                    //         if (currSquare.position.row < this.startSquare.position.row) {
                    //             currSquare.position.row += 1;
                    //             currSquare.startDistance += nonDiagonalCost;
                    //         } else if (currSquare.position.row > this.startSquare.position.row) { 
                    //             currSquare.position.row -= 1;
                    //             currSquare.startDistance += nonDiagonalCost;
                    //         } else;
                    //     } else if (currSquare.position.row == this.startSquare.position.row) {      // check if square is in the same ROW of starting square
                    //         if (currSquare.position.col < this.startSquare.position.col) {
                    //             currSquare.position.col += 1;
                    //             currSquare.startDistance += nonDiagonalCost;
                    //         } else if (currSquare.position.col > this.startSquare.position.col) {
                    //             currSquare.position.col -= 1;
                    //             currSquare.startDistance += nonDiagonalCost;
                    //         } else;
                    //     } else {        // square is diagonally away from the start square
                    //         if (currSquare.position.col < this.startSquare.position.col) { currSquare.position.col += 1; }
                    //         else if (currSquare.position.col > this.startSquare.position.col) {currSquare.position.col -= 1;}
                    //         else;

                    //         if(currSquare.position.row < this.startSquare.position.row) { currSquare.position.row += 1; }
                    //         else if (currSquare.position.row > this.startSquare.position.row) { currSquare.position.row -= 1; }
                    //         else;

                    //         currSquare.startDistance += diagonalCost;
                    //     }
                    // }

                    // square.startDistance = currSquare.startDistance;        // new startDistance

                    currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                    currSquare.goalDistance = 0;        // resetting the value so the main copy doesn't have its value added to
                    
                    // find the goal distance of a square
                    while (currSquare.position.col != this.goalSquare.position.col || currSquare.position.row != this.goalSquare.position.row) {
                        if(currSquare.position.col == this.goalSquare.position.col) {      // check if node is in the same COLUMN of start square
                            if (currSquare.position.row < this.goalSquare.position.row) {
                                currSquare.position.row += 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else if (currSquare.position.row > this.goalSquare.position.row) { 
                                currSquare.position.row -= 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else;
                        } else if (currSquare.position.row == this.goalSquare.position.row) {      // check if node is in the same ROW of start square
                            if (currSquare.position.col < this.goalSquare.position.col) {
                                currSquare.position.col += 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else if (currSquare.position.col > this.goalSquare.position.col) {
                                currSquare.position.col -= 1;
                                currSquare.goalDistance += nonDiagonalCost;
                            } else;
                        } else {        // check if the square is in the same DIAGONAL of start square
                            if (currSquare.position.col < this.goalSquare.position.col) { currSquare.position.col += 1; } 
                            else if (currSquare.position.col > this.goalSquare.position.col) { currSquare.position.col -= 1; }
                            else;

                            if(currSquare.position.row < this.goalSquare.position.row) { currSquare.position.row += 1; } 
                            else if (currSquare.position.row > this.goalSquare.position.row) { currSquare.position.row -= 1; } 
                            else;

                            currSquare.goalDistance += diagonalCost;
                        }
                    }

                    square.goalDistance = currSquare.goalDistance;      // new goalDistance
                    if(square.state != this.startSquare.state && square.state != this.goalSquare.state) 
                        square.total = square.startDistance + square.goalDistancel;       // new total distance
                    else 
                        square.total = 0;      
                }

                setSurroundingSquares(square) {
                    let currSquare = JSON.parse(JSON.stringify(square));
                    let neighborSquare = [];
                    let potentialSquares = [];

                    // up
                    if(currSquare.position.col-1 >= 0) {
                        neighborSquare = this.getSquareByIndex(square.index - this.rowSize);
                        neighborSquare.directionalCost = nonDiagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // down
                    if(currSquare.position.col+1 < this.columnSize) {
                        neighborSquare = this.getSquareByIndex(square.index + this.rowSize);
                        neighborSquare.directionalCost = nonDiagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // left
                    if(currSquare.position.row-1 >= 0) {
                        neighborSquare = this.getSquareByIndex(square.index-1);
                        neighborSquare.directionalCost = nonDiagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // right
                    if(currSquare.position.row+1 < this.rowSize)  {
                        neighborSquare = this.getSquareByIndex(square.index + 1);
                        neighborSquare.directionalCost = nonDiagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // up left
                    if(currSquare.position.col-1 >= 0 && currSquare.position.row-1 >= 0){
                        neighborSquare = this.getSquareByIndex(square.index - (this.rowSize + 1));
                        neighborSquare.directionalCost = diagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // up right
                    if(currSquare.position.col-1 >= 0 && currSquare.position.row+1 < this.rowSize){
                        neighborSquare = this.getSquareByIndex(square.index - (this.rowSize - 1));
                        neighborSquare.directionalCost = diagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // down left
                    if(currSquare.position.col+1 < this.columnSize && currSquare.position.row-1 >= 0) {
                        neighborSquare = this.getSquareByIndex(square.index + (this.rowSize - 1));
                        neighborSquare.directionalCost = diagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // down right
                    if(currSquare.position.col+1 < this.columnSize && currSquare.position.row+1 < this.rowSize) {
                        neighborSquare = this.getSquareByIndex(square.index + (this.rowSize + 1));
                        neighborSquare.directionalCost = diagonalCost;
                        potentialSquares.push(neighborSquare);
                    }

                    // only keep unvisited, blank, and goal squares
                    for(let i = 0; i < potentialSquares.length; i++) {
                        if(potentialSquares[i].state != unvisited && potentialSquares[i].state != blank && potentialSquares[i].state != goal ) {
                            potentialSquares.splice(i, 1);  // remove the node since its either the wall, visited, or start square
                            i--;
                        } else {
                            if(potentialSquares[i].state == goal) { // if goal is found then just return and add it to the unexplored squares
                                potentialSquares[i].parent = square;
                                let newSquare = JSON.parse(JSON.stringify(potentialSquares[i]))
                                this.unexploredSquares.push(newSquare);
                                return;
                            }

                            if(potentialSquares[i].total == 0) {        // if the square is blank then just update it based on the square that is discovering it
                                // update the neighbor square's state, start distance, and total values
                                this.setSquareDistance(potentialSquares[i]);    // to get the goal cost
                                potentialSquares[i].startDistance = square.startDistance + potentialSquares[i].directionalCost;
                                potentialSquares[i].total = potentialSquares[i].startDistance + potentialSquares[i].goalDistance;
                                potentialSquares[i].parent = square;
                                potentialSquares[i].startDistance = currSquare.startDistance + potentialSquares[i].directionalCost;
                                potentialSquares[i].total = potentialSquares[i].startDistance + potentialSquares[i].goalDistance;
                                potentialSquares[i].state = unvisited;
                                this.changeSquareColor(potentialSquares[i], unvisited);

                                this.updateSquareCost(potentialSquares[i]);
                            } else {
                                console.log("maybe modify the square?");
                                if(potentialSquares[i].total > square.startDistance + potentialSquares[i].goalDistance + potentialSquares[i].directionalCost) {
                                    potentialSquares[i].startDistance = square.startDistance + potentialSquares[i].directionalCost;
                                    potentialSquares[i].total = potentialSquares[i].startDistance + potentialSquares[i].goalDistance;
                                    this.updateSquareCost(potentialSquares[i]);
                                }
                            }
                        }
                    }

                    // add squares to the unexploredSquares array if any
                    if(this.unexploredSquares.length > 0 && potentialSquares.length > 0) {  // case of both arrays having items in them
                        for(let i = 0; i < this.unexploredSquares.length; i++) {
                            for(let j = 0; j < potentialSquares.length; j++) {
                                // ensure duplicates are rewritten and assigned to the unexplored array, not added to
                                if(this.unexploredSquares[i].index == potentialSquares[j].index) {
                                    this.unexploredSquares[i] = JSON.parse(JSON.stringify(potentialSquares[j]));    // reassign updated square
                                    potentialSquares.splice(j,1);   // delete that square
                                    j--;
                                }
                            }
                        }

                        this.unexploredSquares = this.unexploredSquares.concat(potentialSquares);   // squares being added are now completely new
                    } else if (potentialSquares.length > 0) {   // case of the unexplored array being empty but not the potentialSquares array
                        for(let i = 0; i < potentialSquares.length; i++) {
                            let newSquare = JSON.parse(JSON.stringify(potentialSquares[i]));
                            this.unexploredSquares.push(newSquare);
                        }
                    }
                }

                // sorts the total costs from the unexplored array in ascending order
                sortTotalCostsAscend() {
                    this.unexploredSquares.sort(function(a,b) {
                        return a.total - b.total;
                    });
                }

                // sorts the total costs from the unexplored array in descending order
                sortTotalCostsDescend() {
                    this.visitedSquares.sort(function(a,b) {
                        return b.total - a.total;
                    });
                }

                // A* algorithm
                a_star() {
                    // reset everything
                    this.clearPath();
                    let currSquare = this.startSquare;
                    let nextSquare = [];
                    let lowestTotalSquare = [];
                    this.unexploredSquares.length = 0;
                    this.visitedSquares.length = 0;

                    this.setSquareDistance(this.startSquare);
                    this.setSquareDistance(this.goalSquare);
                    this.setSurroundingSquares(currSquare);

                    // find the next square to explore
                    while(this.unexploredSquares.length != 0) {
                        let j = 0;
                        this.sortTotalCostsAscend();       // lowest total cost will be the first element
                        lowestTotalSquare = this.unexploredSquares[0];

                        // get the next lowest total cost
                        while(j+1 < this.unexploredSquares.length && lowestTotalSquare.total == this.unexploredSquares[j+1].total) {
                            // if the total costs are the same get the next lowest start distance
                            if(lowestTotalSquare.startDistance > this.unexploredSquares[j+1].startDistance) {
                                lowestTotalSquare = this.unexploredSquares[j+1];
                            }
                            j++;
                        }
                        currSquare = this.getSquareByIndex(lowestTotalSquare.index);
                        this.visitedSquares.push(currSquare);
                        
                        if(currSquare.state == this.goalSquare.state) {
                            while(currSquare.state != this.startSquare.state) {  // color the most optimal path yellow
                                currSquare = currSquare.parent;
                                if(currSquare.state == this.startSquare.state) break;    // so we dont overwrite the start square's color
                                this.gridDOM.children[currSquare.index].style.backgroundColor = "#FFEA7F";
                                this.gridDOM.children[currSquare.index].style.borderColor = "#FFD567";
                            }
                            return;
                        }

                        currSquare.state = visited;
                        this.gridDOM.children[currSquare.index].style.backgroundColor = "#FF848C";
                        this.gridDOM.children[currSquare.index].style.borderColor = "#FF505F";

                        // remove the current square from the unexplored array
                        for(let i = 0; i < this.unexploredSquares.length; i++) {
                            if(this.unexploredSquares[i].position.row == currSquare.position.row && this.unexploredSquares[i].position.col == currSquare.position.col) {
                                this.unexploredSquares.splice(i, 1);
                                break;
                            }
                        }

                        this.setSurroundingSquares(this.getSquareByIndex(currSquare.index));
                    }
                }
            }

            var aStarAlgo = new A_Star();
            var mainElem = document.getElementsByTagName("main")[0];

            class PopUp {
                constructor(popUpName, power) {
                    this.power = power;
                    this.currSlide = 0;
                    this.popUpDOM = document.getElementById(popUpName);
                    if(!power) {
                        this.popUpDOM.style.display = "none";
                    }
                    this.slides = this.popUpDOM.getElementsByClassName("slide"); 
                    this.numOfSlides = this.slides.length;
                    this.slideProgress = this.popUpDOM.getElementsByClassName("slide-progress")[0].children;
                    this.leftButton = this.popUpDOM.getElementsByClassName("slide-buttons")[0].children[0];
                    this.rightButton = this.popUpDOM.getElementsByClassName("slide-buttons")[0].children[1];
                }

                showPopUp() {
                    console.log("pop up is currently on");
                    this.popUpDOM.style.display = "";
                    mainElem.style.opacity = .2;
                    event.stopPropagation();        // this stops from main interfering with this
                }

                changeSlide(num) {
                    if(this.currSlide + num >= 0 && this.currSlide + num < this.numOfSlides) {
                        if(this.currSlide + num == 0) {     // blur the left button if the user is on the first slide
                            this.leftButton.style.opacity = .3;
                        } else if (this.currSlide+num == this.numOfSlides-1) {  // blur the left button if the user is on the last slide
                            this.rightButton.style.opacity = .3;
                        } else {    // unblur both button if the user is not on the first or last slide
                            this.leftButton.style.opacity = 1;
                            this.rightButton.style.opacity = 1;
                        }

                        // hide the current slide the user is on as well as the slide progress bar
                        this.slides[this.currSlide].style.display = "none";
                        this.slideProgress[this.currSlide].style.backgroundColor = "white";

                        // increment to the next slide
                        this.currSlide += num;

                        // show the current slide as well as update the slide progress bar
                        this.slides[this.currSlide].style.display = "";
                        this.slideProgress[this.currSlide].style.backgroundColor = "black";
                    }
                }

                removePopUp() {
                    console.log("pop up is off");

                    this.popUpDOM.style.display = "none";
                    mainElem.style.opacity = 1;
                    this.slides[this.currSlide].style.display = "none";
                    this.currSlide = 0;
                    this.slides[this.currSlide].style.display = "";
                }
            } 

            var tutorialPopUp = new PopUp("tutorial-pop-up", true);
            var aStarInfo = new PopUp("a-star-info", false);


            /* OLD CODE WITHOUT CLASSES */
            var tutorialStatus = true;

            function showCosts() {      // maybe pass in the the algorithms dom in the future since i will be adding more
                console.log("turning on the costs!");
                let costs = aStarAlgo.gridDOM.children;
                if(visible) {
                    aStarAlgo.updateSquareCosts();
                    for(i = 0; i < aStarAlgo.columnSize * aStarAlgo.rowSize; i++) {
                        if(aStarAlgo.gridArray[i].state != wall && aStarAlgo.gridArray[i].state != blank) {
                            console.log(aStarAlgo.gridArray[i].state);
                            costs[i].getElementsByTagName("p")[0].style.display = "";
                            costs[i].getElementsByTagName("p")[1].style.display = "";
                            costs[i].getElementsByTagName("p")[2].style.display = "";
                        }

                    }
                    visible = false;
                } else {
                    console.log("turning off the costs!");
                    visible = true;
                    for(i = 0; i < aStarAlgo.columnSize * aStarAlgo.rowSize; i++) {
                        costs[i].getElementsByTagName("p")[0].style.display = "none";
                        costs[i].getElementsByTagName("p")[1].style.display = "none";
                        costs[i].getElementsByTagName("p")[2].style.display = "none";
                    }
                }
            }

            function showAllCosts() {
                let costs = aStarAlgo.gridDOM.children;
                    for(i = 0; i < aStarAlgo.columnSize * aStarAlgo.rowSize; i++) {
                        costs[i].getElementsByTagName("p")[0].style.display = "";
                        costs[i].getElementsByTagName("p")[1].style.display = "";
                        costs[i].getElementsByTagName("p")[2].style.display = "";
                    }
            }
            showCosts();
        </script>
    </body>
</html>