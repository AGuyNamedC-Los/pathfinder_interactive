<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <!-- Open Graph -->
        <meta property="og:image" content="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/favicon.ico"/>
        <meta property="og:type" content="website"/>
        <meta property="og:url" content=""/>
        <meta property="og:site_name" content="Pathfinder Interactive"/>
        <meta property="og:title" content="Pathfinder Interactive"/>
        <meta property="og:description" content="An interactive pathfinding website that utilizes path finding algorithms to find the most optimal path between two points"/>

		<title>Interactive Pathfinder</title>
		<link href="pathfinder-interactive.css" type="text/css" rel="stylesheet">
		<link rel="icon" href="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/favicon.ico">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    </head>
    <body>
        <div id="pop-up">
            <div class="tutorial tutorial-1">
                <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-1.gif"/>
                <p>
                    Pathfinder interactive finds the most optimal path between the starting and goal squares.
                    While also allowing you to move the positions of both the starting and goal squares!<br><br>
                </p>
            </div>
            <div class="tutorial tutorial-2" style=display:none>
                <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-2.gif"/>
                <p>
                    Create walls that make it more difficult for the pathfinding algorithm to find the goal square! Simply 
                    click and drag on blank squares to create black walls. Clicking and dragging on black squares will 
                    create blank squares.
                </p>
            </div>
            <div class="tutorial tutorial-3" style=display:none>
                <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-3.gif"/>
                <p>
                    Note! It is possible to not come to a solution if you create enough walls<br><br><br>
                </p>
            </div>
            <div class="tutorial tutorial-4" style=display:none>
                <img src="https://raw.githubusercontent.com/AGuyNamedC-Los/pathfinder_interactive/master/tutorial-4.gif"/>
                <p>
                    For now, A* is the only algorithm being used for pathfinding. More soon to come aswell as
                    more features!<br><br><br>
                </p>
            </div>
            <div class="tutorial-buttons">
                <button onmousedown="changeSlide(-1)">PREV</button>
                <button onmousedown="changeSlide(1)">NEXT</button>
            </div>
        </div>
        <main onmousedown="removePopUp()">
            <nav>
                <button onclick="a_star()">Pathfind!</button>
                <button onclick="resetGraph()">Reset</button>
                <button onmousedown="popUp()">Tutorial</button>
            </nav>
            <div id="square-legend">
                <div id="start">
                    <div></div>
                    <p>Starting<br>Point</p>
                </div>
                <div id="goal">
                    <div></div>
                    <p>Goal</p>
                </div>
                <div id="wall">
                    <div></div>
                    <p>Wall</p>
                </div>
                <div id="visited">
                    <div></div>
                    <p>Visited</p>
                </div>
                <div id="unvisited">
                    <div></div>
                    <p>Unvisited</p>
                </div>
                <div id="path">
                    <div></div>
                    <p>Optimal<br>Path</p>
                </div>
            </div>
            <div id="grid-container" onmouseup="stopPainting()"></div>
        </main>
        <script>
            var gridRowSize = 15;
            var gridColumnSize = 10;
            var gridArray = [];
            var startSquare = [];
            var goalSquare = [];
            var unexploredSquares = [];
            var newGrid = document.getElementById("grid-container");
            var grid = document.getElementById("grid-container");
            var isPainting = false;
            var isMovingStart = false;
            var isMovingGoal = false;
            var power = "on";
            var tutorialStatus = true;
            var currSlide = 0;
            var numOfSlides = document.getElementsByClassName("tutorial").length - 1;
            const diagonalCost = 14;
            const nonDiagonalCost = 10;
            const start = "start";
            const goal = "goal";
            const wall = "wall";
            const blank = "blank";
            const visited = "visited";
            const unvisited = "unvisited";

            var mainElem = document.getElementsByTagName("main")[0];

            function removePopUp() {
                var popUp = document.getElementById("pop-up");
                console.log("tutorial is currently being turned off");
                popUp.style.display = "none";
                mainElem.style.opacity = 1;
                let tutorialSlide = document.getElementsByClassName("tutorial")[currSlide];
                tutorialSlide.style.display = "none";
                currSlide = 0;
                tutorialSlide = document.getElementsByClassName("tutorial")[currSlide];
                tutorialSlide.style.display = "";
            }

            function popUp() {
                var popUp = document.getElementById("pop-up");
                console.log("tutorial is currently being turned on");
                popUp.style.display = "";
                mainElem.style.opacity = .2;
                event.stopPropagation();        // this stops from main interfering with this
            }

            function changeSlide(num) {
                if(currSlide+num > 0 && currSlide+num <= numOfSlides) {
                    let tutorialSlide = document.getElementsByClassName("tutorial")[currSlide];
                    currSlide += num;
                    tutorialSlide.style.display = "none";
                    tutorialSlide = document.getElementsByClassName("tutorial")[currSlide];
                    tutorialSlide.style.display = "";
                }
            }

            for(i = 0; i < gridColumnSize; i++) {
                for(j = 0; j < gridRowSize; j++) {
                    gridArray.push({"index": (i*gridRowSize)+j, "position": {"row": j, "col": i}, "state": blank, "parent": "", "startDistance": 0, "goalDistance": 0, "total": 0});
                }
            }

            // setting the initial start and goal node
            gridArray[gridArray.length-1].state = start;
            gridArray[0].state = goal;

            for(i = 0; i < gridRowSize * gridColumnSize; i++) {
                if (gridArray[i].state != start && gridArray[i].state != goal) {
                    $("#grid-container").append(`<div onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()" class=square>
                                                <p onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()">${gridArray[i]['startDistance']}</p>
                                                <p onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()">${gridArray[i]['total']}</p>
                                                <p onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()">${gridArray[i]['goalDistance']}</p>
                                            </div>`);
                } else if (gridArray[i].state == start) {
                    startSquare = gridArray[i];
                    $("#grid-container").append(`<div onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()" class=square>
                                                <p>${gridArray[i]['startDistance']}</p>
                                                <p>${gridArray[i]['total']}</p>
                                                <p>${gridArray[i]['goalDistance']}</p>
                                            </div>`);
                } else {
                    goalSquare = gridArray[i];
                    $("#grid-container").append(`<div onmousedown="changeSquare('${gridArray[i].index}')" onmouseover="painting('${gridArray[i].index}')" onmouseup="stopPainting()" class=square>
                                                <p>${gridArray[i]['startDistance']}</p>
                                                <p>${gridArray[i]['total']}</p>
                                                <p>${gridArray[i]['goalDistance']}</p>
                                            </div>`);
                }

                let cssGrid = document.getElementById("grid-container");
                cssGrid.style.gridTemplateColumns = `repeat(${gridRowSize}, 65px)`;
                cssGrid.style.gridTemplateRows = `repeat(${gridColumnSize}, 65px)`;
            }

            showSquareCosts();

            function resetGraph() {
                gridArray.length = 0;
                let tempStart = JSON.parse(JSON.stringify(startSquare));
                let tempGoal = JSON.parse(JSON.stringify(goalSquare));

                for(i = 0; i < gridColumnSize; i++) {
                    for(j = 0; j < gridRowSize; j++) {
                        gridArray.push({"index": (i*gridRowSize)+j, "position": {"row": j, "col": i}, "state": blank, "parent": "", "startDistance": 0, "goalDistance": 0, "total": 0});
                    }
                }

                gridArray[tempStart.index] = tempStart;
                startSquare = gridArray[tempStart.index];

                gridArray[tempGoal.index] = tempGoal;
                goalSquare = gridArray[tempGoal.index];

                showSquareCosts();
                unexploredSquares.length = 0;
            }

            function changeSquare(index) {
                if(gridArray[index].state == start) {       // ensure only the start square can be moved
                    isMovingStart = true;
                    return;
                } else if(gridArray[index].state == goal) {     // ensure only the goal square can be moved
                    isMovingGoal = true;
                    return;
                }

                isPainting = true;
                if(gridArray[index].state == blank) {
                    newGrid.children[index].style.backgroundColor = "black";
                    gridArray[index].state = wall;
                } else if(gridArray[index].state == wall) {
                    newGrid.children[index].style.backgroundColor = "#f2f2f2";
                    newGrid.children[index].style.borderColor = "#959595";
                    gridArray[index].state = blank;
                }
            }

            // allows the ability to click and drag squares
            function painting(i) {
                let temp = [];
                if(isMovingStart) {     // allows the ability to click and drag the start square
                    let temp = JSON.parse(JSON.stringify(startSquare));
                    startSquare = gridArray[i];
                    startSquare.state = start;
                    newGrid.children[startSquare.index].style.backgroundColor = "#00DDFF";
                    newGrid.children[startSquare.index].style.borderColor = "#0290EE";
                    gridArray[temp.index].state = blank;
                    newGrid.children[temp.index].style.backgroundColor = "#f2f2f2";
                    newGrid.children[temp.index].style.borderColor = "#959595";
                    return;
                } else if (isMovingGoal) {      // allows the ability to click and drag the goal square
                    let temp = JSON.parse(JSON.stringify(goalSquare));
                    goalSquare = gridArray[i];
                    goalSquare.state = goal;
                    newGrid.children[goalSquare.index].style.backgroundColor = "#C588FF";
                    newGrid.children[goalSquare.index].style.borderColor = "#9059FF";
                    gridArray[temp.index].state = blank;
                    newGrid.children[temp.index].style.backgroundColor = "#f2f2f2";
                    newGrid.children[temp.index].style.borderColor = "#959595";
                    return;
                }

                if(isPainting) {        // allows the ability to click and drag to create walls or delete walls
                    if(gridArray[i].state == blank) {
                        newGrid.children[i].style.backgroundColor = "black";
                        gridArray[i].state = wall;
                    } else if(gridArray[i].state == wall) {
                        newGrid.children[i].style.backgroundColor = "#f2f2f2";
                        newGrid.children[i].style.borderColor = "#959595";
                        gridArray[i].state = blank
                    }
                }
            }

            // stops the ability to click and drag a square after a onmouseup event
            function stopPainting() {
                if(isMovingStart) { isMovingStart = false; } 
                else if (isMovingGoal) { isMovingGoal = false; } 
                else if(isPainting) { isPainting = false; }
            }

            // returns a square from the grid from a given set of coordinates
            function getSquare(row, col) {
                for (i = 0; i < gridColumnSize * gridRowSize; i++)
                    if(gridArray[i].position.row == row && gridArray[i].position.col == col)
                        return gridArray[i];
            }

            // calculates distance of the start and goal squares from a given square
            function setSquareDistance(square) {
                let currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                currSquare.startDistance = 0;       // resetting the value so the main copy doesn't have its value added to it

                // find the start distance of the current square
                while (currSquare.position.col != startSquare.position.col || currSquare.position.row != startSquare.position.row) {
                    if(currSquare.position.col == startSquare.position.col) {      // check if square is in the same COLUMN of starting square
                        if (currSquare.position.row < startSquare.position.row) {
                            currSquare.position.row += 1;
                            currSquare.startDistance += nonDiagonalCost;
                        } else if (currSquare.position.row > startSquare.position.row) { 
                            currSquare.position.row -= 1;
                            currSquare.startDistance += nonDiagonalCost;
                        } else;
                    } else if (currSquare.position.row == startSquare.position.row) {      // check if square is in the same ROW of starting square
                        if (currSquare.position.col < startSquare.position.col) {
                            currSquare.position.col += 1;
                            currSquare.startDistance += nonDiagonalCost;
                        } else if (currSquare.position.col > startSquare.position.col) {
                            currSquare.position.col -= 1;
                            currSquare.startDistance += nonDiagonalCost;
                        } else;
                    } else {        // square is diagonally away from the start square
                        if (currSquare.position.col < startSquare.position.col) { currSquare.position.col += 1; }
                        else if (currSquare.position.col > startSquare.position.col) {currSquare.position.col -= 1;}
                        else;

                        if(currSquare.position.row < startSquare.position.row) { currSquare.position.row += 1; }
                        else if (currSquare.position.row > startSquare.position.row) { currSquare.position.row -= 1; }
                        else;

                        currSquare.startDistance += diagonalCost;
                    }
                }

                square.startDistance = currSquare.startDistance;        // new startDistance

                currSquare = JSON.parse(JSON.stringify(square));        // creating a deep copy as to not affect the original square just yet
                currSquare.goalDistance = 0;        // resetting the value so the main copy doesn't have its value added to
                
                // find the goal distance of a square
                while (currSquare.position.col != goalSquare.position.col || currSquare.position.row != goalSquare.position.row) {
                    if(currSquare.position.col == goalSquare.position.col) {      // check if node is in the same COLUMN of start square
                        if (currSquare.position.row < goalSquare.position.row) {
                            currSquare.position.row += 1;
                            currSquare.goalDistance += nonDiagonalCost;
                        } else if (currSquare.position.row > goalSquare.position.row) { 
                            currSquare.position.row -= 1;
                            currSquare.goalDistance += nonDiagonalCost;
                        } else;
                    } else if (currSquare.position.row == goalSquare.position.row) {      // check if node is in the same ROW of start square
                        if (currSquare.position.col < goalSquare.position.col) {
                            currSquare.position.col += 1;
                            currSquare.goalDistance += nonDiagonalCost;
                        } else if (currSquare.position.col > goalSquare.position.col) {
                            currSquare.position.col -= 1;
                            currSquare.goalDistance += nonDiagonalCost;
                        } else;
                    } else {        // check if the square is in the same DIAGONAL of start square
                        if (currSquare.position.col < goalSquare.position.col) { currSquare.position.col += 1; } 
                        else if (currSquare.position.col > goalSquare.position.col) { currSquare.position.col -= 1; }
                        else;

                        if(currSquare.position.row < goalSquare.position.row) { currSquare.position.row += 1; } 
                        else if (currSquare.position.row > goalSquare.position.row) { currSquare.position.row -= 1; } 
                        else;

                        currSquare.goalDistance += diagonalCost;
                    }
                }

                square.goalDistance = currSquare.goalDistance;      // new goalDistance
                if(square != startSquare && square != goalSquare) 
                    square.total = square.startDistance + square.goalDistancel;       // new total distance
                else 
                    square.total = 0;      
            }

            function setSurroundingSquares(square) {
                let currSquare = JSON.parse(JSON.stringify(square));
                
                // set up square
                if (currSquare.position.col-1 >= 0) {
                    let neighborSquare = getSquare(currSquare.position.row, currSquare.position.col-1);

                    if(neighborSquare.state == unvisited || neighborSquare.state == blank || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + nonDiagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        // check to see if the square already exists in the unexplored array, if it 
                        // does exist in the array then don't add it to the array since it will already been updated by the code above
                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // set down square
                if (currSquare.position.col+1 < gridColumnSize) {
                    let neighborSquare = getSquare(currSquare.position.row, (currSquare.position.col+1));

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + nonDiagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // set left square
                if (currSquare.position.row-1 >= 0) {
                    let neighborSquare = getSquare((currSquare.position.row-1), currSquare.position.col);

                    if(neighborSquare.state == "unvisited" || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + nonDiagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // set right square
                if (currSquare.position.row+1 < gridRowSize) {
                    let neighborSquare = getSquare((currSquare.position.row+1), currSquare.position.col);

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + nonDiagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // up left
                if(currSquare.position.col-1 >= 0 && currSquare.position.row-1 >= 0) {
                    let neighborSquare = getSquare((currSquare.position.row-1), (currSquare.position.col-1));

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + diagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // up right
                if(currSquare.position.col-1 >= 0 && currSquare.position.row+1 < gridRowSize) {
                    let neighborSquare = getSquare((currSquare.position.row+1), (currSquare.position.col-1));

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + diagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // down left
                if(currSquare.position.col+1 < gridColumnSize && currSquare.position.row-1 >= 0) {
                    let neighborSquare = getSquare((currSquare.position.row-1), (currSquare.position.col+1));

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + diagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }

                // down right
                if(currSquare.position.col+1 < gridColumnSize && currSquare.position.row+1 < gridRowSize) {
                    let neighborSquare = getSquare((currSquare.position.row+1), (currSquare.position.col+1));

                    if(neighborSquare.state == unvisited || neighborSquare.state == "blank" || neighborSquare.state == goal) {
                        if(neighborSquare.state == goal) {
                            neighborSquare.parent = square;
                            newGrid.children[neighborSquare.index].style.backgroundColor = "#C588FF";
                            newGrid.children[neighborSquare.index].style.borderColor = "9059FF";
                            unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                            return;
                        }

                        // css for squares
                        newGrid.children[neighborSquare.index].style.backgroundColor = "#88FFD1";
                        newGrid.children[neighborSquare.index].style.borderColor = "#3FE1B0";

                        // update the neighbor square's state, start distance, and total values
                        setSquareDistance(neighborSquare);
                        neighborSquare.parent = square;
                        neighborSquare.startDistance = currSquare.startDistance + diagonalCost;
                        neighborSquare.total = neighborSquare.startDistance + neighborSquare.goalDistance;
                        neighborSquare.state = unvisited;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[0].innerHTML = neighborSquare.startDistance;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[1].innerHTML = neighborSquare.total;
                        newGrid.children[neighborSquare.index].getElementsByTagName("p")[2].innerHTML = neighborSquare.goalDistance;

                        let duplicate = false;
                        if(unexploredSquares.length > 0) {
                            for(i = 0; i < unexploredSquares.length; i++) {
                                if(unexploredSquares[i].position.row == neighborSquare.position.row && 
                                unexploredSquares[i].position.col == neighborSquare.position.col){
                                    duplicate = true;
                                    unexploredSquares[i] = JSON.parse(JSON.stringify(neighborSquare));      // update the square thats already in the array
                                    break;
                                }
                            }
                            if(!duplicate) unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));
                        } else {unexploredSquares.push(JSON.parse(JSON.stringify(neighborSquare)));}
                    }
                }
            }

            // this function will sort the total costs from the unexplored array in ascending order
            function sortTotalCosts() {
                unexploredSquares.sort(function(a,b) {
                    return a.total - b.total;
                });
            }

            function a_star() {
                let currSquare = startSquare;
                let nextSquare = [];
                let lowestTotalSquare = [];

                setSquareDistance(startSquare);
                setSquareDistance(goalSquare);
                setSurroundingSquares(currSquare);

                // find the next square to explore
                while(unexploredSquares.length != 0) {
                    let j = 0;
                    sortTotalCosts();       // lowest total cost will be the first element
                    lowestTotalSquare = unexploredSquares[0];

                    while(j+1 < unexploredSquares.length && lowestTotalSquare.total == unexploredSquares[j+1].total) {
                        if(lowestTotalSquare.goalDistance > unexploredSquares[j+1].goalDistance) {
                            lowestTotalSquare = unexploredSquares[j+1];
                        }
                        j++
                    }
                    currSquare = getSquare(lowestTotalSquare.position.row, lowestTotalSquare.position.col);
                    if(currSquare.state == goalSquare.state) {
                        while(currSquare.state != startSquare.state) {  // color the most optimal path yellow
                            currSquare = currSquare.parent;
                            if(currSquare.state == startSquare.state) break;    // so we dont overwrite the start square's color
                            newGrid.children[currSquare.index].style.backgroundColor = "#FFEA7F";
                            newGrid.children[currSquare.index].style.borderColor = "#FFD567";
                        }
                        return;
                    }
                    currSquare.state = visited;
                    newGrid.children[currSquare.index].style.backgroundColor = "#FF848C";
                    newGrid.children[currSquare.index].style.borderColor = "#FF505F";

                    setSurroundingSquares(getSquare(currSquare.position.row, currSquare.position.col));

                    // remove current square from the unexplored array
                    for(i = 0; i < unexploredSquares.length; i++) {
                        if(unexploredSquares[i].position.row == currSquare.position.row && unexploredSquares[i].position.col == currSquare.position.col) {
                            unexploredSquares.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            function showSquareCosts() {
                for(i = 0; i < gridColumnSize * gridRowSize; i++) {
                    if(gridArray[i].state == blank) {
                        newGrid.children[i].style.backgroundColor = "#f2f2f2";
                        newGrid.children[i].style.borderColor = "#959595";
                    } else if(gridArray[i].state == unvisited) {
                        newGrid.children[i].style.backgroundColor = "#88FFD1";
                        newGrid.children[i].style.borderColor = "#3FE1B0";
                    } else if(gridArray[i].state == visited) { 
                        newGrid.children[i].style.backgroundColor = "#FF848C";
                        newGrid.children[i].style.borderColor = "#FF505F";
                    } else if(gridArray[i].state == start) {
                        newGrid.children[i].style.backgroundColor = "#00DDFF";
                        newGrid.children[i].style.borderColor = "#0290EE";
                    } else if(gridArray[i].state == goal) {
                        newGrid.children[i].style.backgroundColor = "#C588FF";
                        newGrid.children[i].style.borderColor = "#9059FF";
                    } else if (gridArray[i].state == wall) {
                        newGrid.children[i].style.backgroundColor = "black";
                    } else {

                    }
                    newGrid.children[i].getElementsByTagName("p")[0].innerHTML = gridArray[i].startDistance;
                    newGrid.children[i].getElementsByTagName("p")[1].innerHTML = gridArray[i].total;
                    newGrid.children[i].getElementsByTagName("p")[2].innerHTML = gridArray[i].goalDistance;
                }
            }
        </script>
    </body>
</html>